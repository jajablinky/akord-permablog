"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiClient = void 0;
const axios_1 = __importDefault(require("axios"));
const uuid_1 = require("uuid");
class ApiClient {
    constructor() {
        this._dir = "files";
        this._filesDir = "files";
        this._publicDataDir = "public";
        this._contractUri = "contracts";
        this._transactionUri = "transactions";
        this._stateDir = "states";
        this._responseType = "json";
        this.addQueryParams = function (url, params) {
            Object.entries(params).forEach(([key, value], index) => {
                if (value) {
                    let queryParam = index === 0 ? "?" : "&";
                    queryParam += encodeURIComponent(key);
                    queryParam += "=" + encodeURIComponent(value.toString());
                    url += queryParam;
                }
            });
            return url;
        };
    }
    env(config) {
        this._apiurl = config.apiurl;
        this._storageurl = config.storageurl;
        return this;
    }
    auth(jwt) {
        this._jwt = jwt;
        return this;
    }
    resourceId(resourceId) {
        this._resourceId = resourceId;
        return this;
    }
    public(isPublic) {
        this._isPublic = isPublic;
        return this;
    }
    bundle(shouldBundleTransaction) {
        this._shouldBundleTransaction = shouldBundleTransaction;
        return this;
    }
    asArrayBuffer() {
        this.setResponseType("arraybuffer");
        return this;
    }
    vaultId(vaultId) {
        this._vaultId = vaultId;
        return this;
    }
    data(data) {
        this._data = data;
        return this;
    }
    queryParams(queryParams) {
        this._queryParams = queryParams;
        return this;
    }
    tags(tags) {
        this._tags = tags;
        return this;
    }
    metadata(metadata) {
        this._metadata = metadata;
        if (metadata && metadata.dataRefs) {
            this._dataRefs = typeof metadata.dataRefs === 'string' ? metadata.dataRefs : JSON.stringify(metadata.dataRefs);
        }
        return this;
    }
    setResponseType(responseType) {
        this._responseType = responseType;
        return this;
    }
    progressHook(hook, processed, total) {
        this._progressHook = hook;
        this._processed = processed;
        this._total = total;
        return this;
    }
    cancelHook(hook) {
        this._cancelHook = hook;
        return this;
    }
    input(input) {
        this._input = input;
        return this;
    }
    numberOfChunks(numberOfChunks) {
        this._numberOfChunks = numberOfChunks;
        return this;
    }
    /**
     *
     * @requires:
     * - auth()
     * @uses:
     * - data()
     */
    contract() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.post(`${this._apiurl}/${this._contractUri}`);
            return response.contractTxId;
        });
    }
    getContract() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.public(true).get(`${this._storageurl}/${this._contractUri}/${this._vaultId}`);
        });
    }
    getNode() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.public(true).get(`${this._apiurl}/nodes/${this._resourceId}`);
        });
    }
    getNodes() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/nodes/${this._resourceId}`);
        });
    }
    updateProfile() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.fetch("put", `${this._apiurl}/profiles`);
        });
    }
    deleteVault() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.fetch("delete", `${this._apiurl}/vaults/${this._vaultId}`);
        });
    }
    getUser() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/users/${this._resourceId}`);
        });
    }
    getProfile() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/profiles`);
        });
    }
    getMembers() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/vaults/${this._vaultId}/members`);
        });
    }
    getNotifications() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/notifications`);
        });
    }
    getMemberships() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/memberships`);
        });
    }
    getVaults() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/vaults`);
        });
    }
    getMembershipKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/vaults/${this._vaultId}/keys`);
        });
    }
    getObjects() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/vaults/${this._vaultId}/nodes`);
        });
    }
    getObject() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this._apiurl}/objects/${this._resourceId}`);
        });
    }
    invite() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.post(`${this._apiurl}/vaults/${this._vaultId}/members`);
            return response.id;
        });
    }
    inviteResend() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.post(`${this._apiurl}/vaults/${this._vaultId}/members/${this._resourceId}`);
            return response.id;
        });
    }
    post(url) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch("post", url);
        });
    }
    get(url) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetch("get", url);
        });
    }
    fetch(method, url) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._jwt && !this._isPublic) {
                throw Error("Authentication is required to use Akord API");
            }
            const config = {
                method,
                url: this._queryParams ? this.addQueryParams(url, this._queryParams) : url,
                headers: {
                    'Authorization': 'Bearer ' + this._jwt,
                    'Content-Type': 'application/json'
                }
            };
            if (this._data) {
                config.data = this._data;
            }
            const response = yield (0, axios_1.default)(config);
            return response.data;
        });
    }
    /**
     *
     * @requires:
     * - auth()
     * - contractId()
     * - input()
     * - metadata()
     * @uses:
     * - tags()
     */
    transaction() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._input) {
                throw Error("Input is required to use /transactions endpoint");
            }
            if (!this._metadata) {
                throw Error("Metadata is required to use /transactions endpoint");
            }
            this.data({
                contractId: this._vaultId,
                input: this._input,
                metadata: this._metadata,
                tags: this._tags,
                state: this._data
            });
            const response = yield this.post(`${this._apiurl}/${this._transactionUri}`);
            return response.txId;
        });
    }
    /**
     * Schedules transaction posting
     * @requires:
     * - auth()
     * - resourceId()
     * - metadata()
     * @uses:
     * - tags()
     */
    asyncTransaction() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._resourceId) {
                throw Error("Resource id is required to use /transactions/files endpoint");
            }
            const tags = this._tags.filter((tag) => tag.name !== "Public-Key");
            this.data({
                resourceUrl: this._resourceId,
                tags: tags,
                async: true,
                numberOfChunks: this._numberOfChunks
            });
            yield this.post(`${this._apiurl}/${this._transactionUri}/files`);
        });
    }
    /**
     *
     * @requires:
     * - auth()
     * - data()
     * @uses:
     * - tags()
     * - dataRefs()
     * - resourceId()
     */
    uploadState() {
        return __awaiter(this, void 0, void 0, function* () {
            this._dir = this._stateDir;
            let resourceTx;
            if (this._shouldBundleTransaction) {
                resourceTx = yield this.stateTransaction();
            }
            else {
                resourceTx = (yield this.upload()).resourceTx;
            }
            return { resourceUrl: this._resourceId || resourceTx, id: resourceTx, resourceTx: resourceTx };
        });
    }
    /**
     *
     * @requires:
     * - auth()
     * - data()
     * @uses:
     * - tags()
     * - dataRefs()
     * - resourceId()
     */
    uploadFile() {
        return __awaiter(this, void 0, void 0, function* () {
            this._dir = this._filesDir;
            yield this.upload();
            const resourceId = this._resourceId;
            const resourceTx = this._shouldBundleTransaction ? yield this.fileTransaction() : null;
            return { resourceUrl: resourceId, id: resourceTx, resourceTx: resourceTx };
        });
    }
    /**
     *
     * @requires:
     * - auth()
     * - resourceId()
     */
    downloadFile() {
        return __awaiter(this, void 0, void 0, function* () {
            this._dir = this._filesDir;
            return yield this.download();
        });
    }
    /**
  *
  * @requires:
  * - auth()
  * - resourceId()
  */
    downloadState() {
        return __awaiter(this, void 0, void 0, function* () {
            this._dir = this._stateDir;
            return yield this.download();
        });
    }
    /**
    * Creates data item from uploaded resource. Schedules bundled transaction
    * @requires:
    * - auth()
    * - resourceId()
    * - metadata()
    * @uses:
    * - tags()
    */
    fileTransaction() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._resourceId) {
                this._resourceId = (0, uuid_1.v4)();
            }
            const tags = (_a = this._tags) === null || _a === void 0 ? void 0 : _a.filter((tag) => tag.name !== "Public-Key");
            this.data({
                resourceUrl: this._resourceId,
                tags: tags
            });
            const response = yield this.post(`${this._apiurl}/${this._transactionUri}/files`);
            return response.txId;
        });
    }
    /**
    * Creates data item from uploaded resource. Schedules bundled transaction
    * @requires:
    * - auth()
    * - metadata()
    * - data()
    * @uses:
    * - tags()
    * - resourceId()
    */
    stateTransaction() {
        return __awaiter(this, void 0, void 0, function* () {
            const tags = this._tags.filter((tag) => tag.name !== "Public-Key");
            this.data({
                resourceUrl: this._resourceId,
                tags: tags,
                data: this._data
            });
            const response = yield this.post(`${this._apiurl}/${this._transactionUri}/states`);
            return response.txId;
        });
    }
    upload() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._jwt) {
                throw Error("Authentication is required to use Akord API");
            }
            if (!this._data) {
                throw Error('Missing data to upload. Use ApiClient#data() to add it');
            }
            if (!this._resourceId) {
                this._resourceId = this._isPublic ? this._publicDataDir + '/' + (0, uuid_1.v4)() : (0, uuid_1.v4)();
            }
            const me = this;
            const config = {
                method: 'put',
                url: `${this._storageurl}/${this._dir}/${this._resourceId}`,
                data: this._data,
                headers: {
                    'Authorization': 'Bearer ' + this._jwt,
                    'Content-Type': 'application/octet-stream'
                },
                signal: this._cancelHook ? this._cancelHook.signal : null,
                onUploadProgress(progressEvent) {
                    if (me._progressHook) {
                        let progress;
                        if (me._total) {
                            progress = Math.round((me._processed + progressEvent.loaded) / me._total * 100);
                        }
                        else {
                            progress = Math.round(progressEvent.loaded / progressEvent.total * 100);
                        }
                        me._progressHook(progress, { id: me._resourceId, total: progressEvent.total });
                    }
                }
            };
            if (this._dataRefs) {
                config.headers['x-amz-meta-datarefs'] = this._dataRefs;
            }
            if (!this._shouldBundleTransaction) {
                config.headers['x-amz-meta-skipbundle'] = "true";
            }
            if (this._tags) {
                for (let tag of this._tags) {
                    // TODO: move it into the API
                    // ensure S3 backward compatibility
                    if (tag.name === "Encrypted-Key") {
                        config.headers['x-amz-meta-encryptedkey'] = tag.value;
                    }
                    else if (tag.name === "Initialization-Vector") {
                        config.headers['x-amz-meta-iv'] = tag.value;
                    }
                    else if (tag.name === "Public-Key") {
                        config.headers['x-amz-publickey'] = tag.value;
                    }
                    else {
                        config.headers['x-amz-meta-' + tag.name.toLowerCase()] = tag.value;
                    }
                }
                config.headers['x-amz-meta-tags'] = JSON.stringify(this._tags.filter((tag) => tag.name !== "Public-Key"));
            }
            const response = yield (0, axios_1.default)(config);
            return { resourceUrl: this._resourceId, resourceTx: response.data.resourceTx };
        });
    }
    download() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._jwt && !this._isPublic) {
                throw Error("Authentication is required to use Akord API");
            }
            if (!this._resourceId) {
                throw Error('Missing resource id to download');
            }
            const me = this;
            const config = {
                method: 'get',
                url: `${this._storageurl}/${this._dir}/${this._resourceId}`,
                responseType: this._responseType,
                signal: this._cancelHook ? this._cancelHook.signal : null,
                onDownloadProgress(progressEvent) {
                    if (me._progressHook) {
                        let progress;
                        if (me._total) {
                            const chunkSize = me._total / me._numberOfChunks;
                            progress = Math.round(me._processed / me._total * 100 + progressEvent.loaded / progressEvent.total * chunkSize / me._total * 100);
                        }
                        else {
                            progress = Math.round(progressEvent.loaded / progressEvent.total * 100);
                        }
                        me._progressHook(progress, { id: me._resourceId, total: progressEvent.total });
                    }
                },
            };
            if (!this._isPublic) {
                config.headers = {
                    'Authorization': 'Bearer ' + this._jwt,
                };
            }
            const response = yield (0, axios_1.default)(config);
            const downloadResponse = { resourceUrl: this._resourceId, response: response };
            return downloadResponse;
        });
    }
}
exports.ApiClient = ApiClient;
