"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MembershipService = void 0;
const constants_1 = require("../constants");
const uuid_1 = require("uuid");
const crypto_1 = require("@akord/crypto");
const service_1 = require("./service");
const membership_1 = require("../types/membership");
const list_options_1 = require("../types/list-options");
const contract_1 = require("../types/contract");
class MembershipService extends service_1.Service {
    constructor() {
        super(...arguments);
        this.objectType = constants_1.objectType.MEMBERSHIP;
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with the decrypted membership
     */
    get(membershipId, vaultId, shouldDecrypt = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const membershipProto = yield this.api.getObject(membershipId, this.objectType, vaultId);
            let membership;
            if (shouldDecrypt) {
                const { isEncrypted, keys } = yield this.api.getMembershipKeys(membershipProto.vaultId);
                membership = new membership_1.Membership(membershipProto, keys);
                if (isEncrypted) {
                    yield membership.decrypt();
                }
            }
            else {
                membership = new membership_1.Membership(membershipProto);
            }
            return membership;
        });
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with the decrypted memberships
     */
    list(vaultId, listOptions = list_options_1.defaultListOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const membershipsProto = yield this.api.getObjectsByVaultId(vaultId, this.objectType, listOptions.shouldListAll);
            const { isEncrypted, keys } = yield this.api.getMembershipKeys(vaultId);
            const memberships = [];
            for (const membershipProto of membershipsProto) {
                const membership = new membership_1.Membership(membershipProto, keys);
                if (isEncrypted && listOptions.shouldDecrypt) {
                    yield membership.decrypt();
                }
                memberships.push(membership);
            }
            return memberships;
        });
    }
    /**
     * Invite user with an Akord account
     * @param  {string} vaultId
     * @param  {string} email invitee's email
     * @param  {RoleType} role CONTRIBUTOR or VIEWER
     * @returns Promise with new membership id & corresponding transaction id
     */
    invite(vaultId, email, role) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContext(vaultId);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_INVITE);
            this.setFunction(constants_1.functions.MEMBERSHIP_INVITE);
            const membershipId = (0, uuid_1.v4)();
            this.setObjectId(membershipId);
            const { address, publicKey } = yield this.getUserEncryptionInfo(email, yield this.wallet.getAddress());
            const keysEncrypter = new crypto_1.KeysStructureEncrypter(this.wallet, this.dataEncrypter.keys, publicKey);
            const keys = yield keysEncrypter.encryptMemberKeys([]);
            const body = {
                keys: keys.map((keyPair) => {
                    delete keyPair.publicKey;
                    return keyPair;
                })
            };
            this.tags = [new contract_1.Tag(constants_1.protocolTags.MEMBER_ADDRESS, address)]
                .concat(yield this.getTags());
            const { data, metadata } = yield this.uploadState(body);
            let input = {
                function: this.function,
                address,
                role,
                data
            };
            const txId = yield this.api.postContractTransaction(this.vaultId, input, this.tags, metadata);
            return { membershipId, transactionId: txId };
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    accept(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            const memberDetails = yield this.getProfileDetails();
            yield this.setVaultContextFromObjectId(membershipId, this.objectType);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_ACCEPT);
            const body = {
                memberDetails: yield this.processMemberDetails(memberDetails, true),
                encPublicSigningKey: yield this.processWriteString(yield this.wallet.signingPublicKey())
            };
            this.setFunction(constants_1.functions.MEMBERSHIP_ACCEPT);
            return this.nodeUpdate(body);
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    confirm(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromObjectId(membershipId, this.objectType);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_CONFIRM);
            this.setFunction(constants_1.functions.MEMBERSHIP_INVITE);
            const { address, publicKey } = yield this.getUserEncryptionInfo(this.object.email, yield this.wallet.getAddress());
            const keysEncrypter = new crypto_1.KeysStructureEncrypter(this.wallet, this.dataEncrypter.keys, publicKey);
            const keys = yield keysEncrypter.encryptMemberKeys([]);
            const body = {
                keys: keys.map((keyPair) => {
                    delete keyPair.publicKey;
                    return keyPair;
                })
            };
            this.tags = [new contract_1.Tag(constants_1.protocolTags.MEMBER_ADDRESS, address)]
                .concat(yield this.getTags());
            const { data, metadata } = yield this.uploadState(body);
            let input = {
                function: this.function,
                address,
                data,
                role: this.object.role
            };
            const txId = yield this.api.postContractTransaction(this.vaultId, input, this.tags, metadata);
            return { transactionId: txId };
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    reject(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromObjectId(membershipId, this.objectType);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_REJECT);
            this.setFunction(constants_1.functions.MEMBERSHIP_REJECT);
            return this.nodeUpdate();
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    leave(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromObjectId(membershipId, this.objectType);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_LEAVE);
            this.setFunction(constants_1.functions.MEMBERSHIP_REJECT);
            return this.nodeUpdate();
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    revoke(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromObjectId(membershipId, this.objectType);
            this.setFunction(constants_1.functions.MEMBERSHIP_REVOKE);
            let data;
            if (!this.isPublic) {
                // generate a new vault key pair
                const keyPair = yield (0, crypto_1.generateKeyPair)();
                const memberships = yield this.api.getObjectsByVaultId(this.vaultId, this.objectType);
                this.tags = yield this.getTags();
                let newMembershipStates = [];
                let newMembershipRefs = [];
                for (let member of memberships) {
                    if (member.id !== this.objectId
                        && (member.status === constants_1.status.ACCEPTED || member.status === constants_1.status.PENDING)) {
                        const { publicKey } = yield this.getUserEncryptionInfo(member.email, member.address);
                        const memberKeysEncrypter = new crypto_1.KeysStructureEncrypter(this.wallet, this.dataEncrypter.keys, publicKey);
                        const keys = [yield memberKeysEncrypter.encryptMemberKey(keyPair)];
                        const newState = yield this.mergeState({ keys });
                        const signature = yield this.signData(newState);
                        newMembershipStates.push({
                            data: newState, tags: [
                                new contract_1.Tag("Data-Type", "State"),
                                new contract_1.Tag(constants_1.protocolTags.SIGNATURE, signature),
                                new contract_1.Tag(constants_1.protocolTags.SIGNER_ADDRESS, yield this.wallet.getAddress()),
                                new contract_1.Tag(constants_1.protocolTags.VAULT_ID, this.vaultId),
                                new contract_1.Tag(constants_1.protocolTags.NODE_TYPE, this.objectType),
                                new contract_1.Tag(constants_1.protocolTags.MEMBERSHIP_ID, member.id)
                            ]
                        });
                        newMembershipRefs.push(member.id);
                    }
                }
                const ids = yield this.api.uploadData(newMembershipStates, true);
                data = [];
                newMembershipRefs.forEach((memberId, memberIndex) => {
                    data.push({ id: memberId, value: ids[memberIndex].id });
                });
            }
            const txId = yield this.api.postContractTransaction(this.vaultId, { function: this.function, data }, this.tags);
            return { transactionId: txId };
        });
    }
    /**
     * @param  {string} membershipId
     * @param  {RoleType} role CONTRIBUTOR or VIEWER
     * @returns Promise with corresponding transaction id
     */
    changeRole(membershipId, role) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromObjectId(membershipId, this.objectType);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_CHANGE_ROLE);
            this.setFunction(constants_1.functions.MEMBERSHIP_CHANGE_ROLE);
            return this.nodeUpdate(null, { role });
        });
    }
    /**
     * Invite user without an Akord account
     * @param  {string} vaultId
     * @param  {string} email invitee's email
     * @param  {string} role CONTRIBUTOR or VIEWER
     * @returns Promise with new membership id & corresponding transaction id
     */
    inviteNewUser(vaultId, email, role) {
        return __awaiter(this, void 0, void 0, function* () {
            const { id } = yield this.api.inviteNewUser(vaultId, email, role);
            return { membershipId: id };
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    inviteResend(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            const object = yield this.api.getObject(membershipId, this.objectType, this.vaultId);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_INVITE_RESEND);
            if (object.status !== constants_1.status.PENDING && object.status !== constants_1.status.INVITED) {
                throw new Error("Cannot resend the invitation for member: " + membershipId +
                    ". Found invalid status: " + object.status);
            }
            yield this.api.inviteResend(object.vaultId, membershipId);
        });
    }
    profileUpdate(membershipId, name, avatar) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromObjectId(membershipId, constants_1.objectType.MEMBERSHIP);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_PROFILE_UPDATE);
            const memberDetails = yield this.processMemberDetails({ name, avatar }, true);
            this.setFunction(constants_1.functions.MEMBERSHIP_UPDATE);
            return this.nodeUpdate({ memberDetails });
        });
    }
}
exports.MembershipService = MembershipService;
;
