/// <reference types="node" />
import { Service } from "./service";
import { FileLike } from "../types/file";
import fs from "fs";
declare class FileService extends Service {
    asyncUploadTreshold: number;
    chunkSize: number;
    /**
     * Returns file as ArrayBuffer. Puts the whole file into memory.
     * For downloading without putting whole file to memory use FileService#download()
     * @param  {string} id file resource url
     * @param  {string} vaultId
     * @param  {DownloadOptions} [options]
     * @returns Promise with file buffer
     */
    get(id: string, vaultId: string, options?: DownloadOptions): Promise<ArrayBuffer>;
    /**
     * Downloads the file keeping memory consumed (RAM) under defiend level: this#chunkSize.
     * In browser, streaming of the binary requires self hosting of mitm.html and sw.js
     * See: https://github.com/jimmywarting/StreamSaver.js#configuration
     * @param  {string} id file resource url
     * @param  {string} vaultId
     * @param  {DownloadOptions} [options]
     * @returns Promise with file buffer
     */
    download(id: string, vaultId: string, options?: DownloadOptions): Promise<void>;
    create(file: FileLike, shouldBundleTransaction?: boolean, progressHook?: (progress: number, data?: any) => void, cancelHook?: AbortController): Promise<{
        resourceTx: string;
        resourceUrl?: string;
        resourceHash: string;
        numberOfChunks?: number;
        chunkSize?: number;
    }>;
    stream(path: string, size?: number): Promise<fs.WriteStream | WritableStreamDefaultWriter>;
    private uploadChunked;
    private uploadChunk;
    private encryptChunk;
    private appendBuffer;
    private getBinary;
}
declare type DownloadOptions = {
    size?: number;
    name?: string;
    isChunked?: boolean;
    numberOfChunks?: number;
    progressHook?: (progress: number) => void;
    cancelHook?: AbortController;
};
export { FileService };
