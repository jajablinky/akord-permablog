"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VaultService = void 0;
const constants_1 = require("../constants");
const uuid_1 = require("uuid");
const crypto_1 = require("@akord/crypto");
const vault_1 = require("../types/vault");
const service_1 = require("./service");
const contract_1 = require("../types/contract");
class VaultService extends service_1.Service {
    constructor() {
        super(...arguments);
        this.objectType = constants_1.objectType.VAULT;
    }
    /**
     * @param  {string} name new vault name
     * @param  {string} [termsOfAccess] if the vault is intended for professional or legal use, you can add terms of access and they must be digitally signed before accessing the vault
     * @param  {boolean} [isPublic]
     * @returns Promise with new vault id, owner membership id & corresponding transaction id
     */
    create(name, termsOfAccess, isPublic) {
        return __awaiter(this, void 0, void 0, function* () {
            const memberDetails = yield this.getProfileDetails();
            this.setActionRef(constants_1.actionRefs.VAULT_CREATE);
            this.setIsPublic(isPublic);
            let publicKeys, keys;
            if (!this.isPublic) {
                // generate a new vault key pair
                const keyPair = yield (0, crypto_1.generateKeyPair)();
                this.setRawDataEncryptionPublicKey(keyPair.publicKey);
                const userPublicKey = yield this.wallet.publicKeyRaw();
                const keysEncrypter = new crypto_1.KeysStructureEncrypter(this.wallet, this.dataEncrypter.keys, userPublicKey);
                keys = [yield keysEncrypter.encryptMemberKey(keyPair)];
                this.setKeys([{ publicKey: (0, crypto_1.arrayToBase64)(keyPair.publicKey), encPrivateKey: keys[0].encPrivateKey }]);
                publicKeys = [(0, crypto_1.arrayToBase64)(keyPair.publicKey)];
            }
            const vaultId = yield this.api.initContractId([new contract_1.Tag(constants_1.protocolTags.NODE_TYPE, constants_1.objectType.VAULT)]);
            this.setFunction(constants_1.functions.VAULT_CREATE);
            this.setVaultId(vaultId);
            this.setObjectId(vaultId);
            const address = yield this.wallet.getAddress();
            const membershipId = (0, uuid_1.v4)();
            this.tags = [
                new contract_1.Tag(constants_1.protocolTags.MEMBER_ADDRESS, address),
                new contract_1.Tag(constants_1.protocolTags.MEMBERSHIP_ID, membershipId),
                new contract_1.Tag(constants_1.protocolTags.PUBLIC, isPublic ? "true" : "false"),
            ].concat(yield this.getTags());
            const vaultData = {
                name: yield this.processWriteString(name),
                termsOfAccess
            };
            const vaultSignature = yield this.signData(vaultData);
            const membershipData = {
                keys,
                encPublicSigningKey: yield this.processWriteString(yield this.wallet.signingPublicKey()),
                memberDetails: yield this.processMemberDetails(memberDetails, true)
            };
            const membershipSignature = yield this.signData(membershipData);
            const ids = yield this.api.uploadData([
                {
                    data: vaultData, tags: [
                        new contract_1.Tag("Data-Type", "State"),
                        new contract_1.Tag(constants_1.protocolTags.SIGNATURE, vaultSignature),
                        new contract_1.Tag(constants_1.protocolTags.SIGNER_ADDRESS, yield this.wallet.getAddress()),
                        new contract_1.Tag(constants_1.protocolTags.VAULT_ID, this.vaultId),
                        new contract_1.Tag(constants_1.protocolTags.NODE_TYPE, this.objectType),
                    ]
                },
                {
                    data: membershipData, tags: [
                        new contract_1.Tag("Data-Type", "State"),
                        new contract_1.Tag(constants_1.protocolTags.SIGNATURE, membershipSignature),
                        new contract_1.Tag(constants_1.protocolTags.SIGNER_ADDRESS, yield this.wallet.getAddress()),
                        new contract_1.Tag(constants_1.protocolTags.VAULT_ID, this.vaultId),
                        new contract_1.Tag(constants_1.protocolTags.NODE_TYPE, constants_1.objectType.MEMBERSHIP),
                        new contract_1.Tag(constants_1.protocolTags.MEMBERSHIP_ID, membershipId)
                    ]
                }
            ], true);
            const metadata = {
                dataRefs: [
                    Object.assign(Object.assign({}, ids[0]), { modelId: this.vaultId, modelType: constants_1.objectType.VAULT, data: vaultData }),
                    Object.assign(Object.assign({}, ids[1]), { modelId: membershipId, modelType: constants_1.objectType.MEMBERSHIP, data: membershipData })
                ],
                publicKeys
            };
            const data = { vault: ids[0].id, membership: ids[1].id };
            const txId = yield this.api.postContractTransaction(this.vaultId, { function: this.function, data }, this.tags, metadata);
            return { vaultId, membershipId, transactionId: txId };
        });
    }
    /**
     * @param vaultId
     * @param name new vault name
     * @returns Promise with corresponding transaction id
     */
    rename(vaultId, name) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContext(vaultId);
            this.setActionRef(constants_1.actionRefs.VAULT_RENAME);
            return this.nodeRename(name);
        });
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with corresponding transaction id
     */
    archive(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContext(vaultId);
            this.setActionRef(constants_1.actionRefs.VAULT_ARCHIVE);
            this.setFunction(constants_1.functions.VAULT_ARCHIVE);
            return this.nodeUpdate();
        });
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with corresponding transaction id
     */
    restore(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContext(vaultId);
            this.setActionRef(constants_1.actionRefs.VAULT_RESTORE);
            this.setFunction(constants_1.functions.VAULT_RESTORE);
            return this.nodeUpdate();
        });
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with corresponding transaction id
     */
    delete(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.api.deleteVault(vaultId);
            return { transactionId: "" };
        });
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with the decrypted vault
     */
    get(vaultId, shouldDecrypt = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.api.getObject(vaultId, this.objectType, vaultId);
            const { keys } = yield this.api.getMembershipKeys(vaultId);
            const vault = new vault_1.Vault(result, keys);
            if (shouldDecrypt && !vault.public) {
                yield vault.decrypt();
            }
            return vault;
        });
    }
    /**
     * @returns Promise with currently authenticated user vaults
     */
    list(shouldDecrypt = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield this.api.getVaults();
            const vaults = [];
            for (let result of results) {
                const vault = new vault_1.Vault(result, result.keys);
                if (shouldDecrypt && !vault.public) {
                    yield vault.decrypt();
                }
                vaults.push(vault);
            }
            return vaults;
        });
    }
    setVaultContext(vaultId) {
        const _super = Object.create(null, {
            setVaultContext: { get: () => super.setVaultContext }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.setVaultContext.call(this, vaultId);
            this.setObjectId(vaultId);
            this.setObject(this.vault);
        });
    }
}
exports.VaultService = VaultService;
;
