"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoService = void 0;
const node_1 = require("./node");
const constants_1 = require("../constants");
const lodash_1 = __importDefault(require("lodash"));
const node_2 = require("../types/node");
class MemoService extends node_1.NodeService {
    constructor() {
        super(...arguments);
        this.objectType = constants_1.objectType.MEMO;
        this.NodeType = node_2.Memo;
    }
    /**
    * @param  {string} vaultId
    * @param  {string} message
    * @returns Promise with new node id & corresponding transaction id
    */
    create(vaultId, message) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContext(vaultId);
            this.setActionRef(constants_1.actionRefs.MEMO_CREATE);
            this.setFunction(constants_1.functions.NODE_CREATE);
            const body = {
                versions: [yield this.memoVersion(message)]
            };
            const { nodeId, transactionId } = yield this.nodeCreate(body);
            return { memoId: nodeId, transactionId };
        });
    }
    /**
    * @param  {string} memoId
    * @param  {reactionEmoji} reaction
    * @returns Promise with corresponding transaction id
    */
    addReaction(memoId, reaction) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromObjectId(memoId, this.objectType);
            this.setActionRef(constants_1.actionRefs.MEMO_ADD_REACTION);
            this.setFunction(constants_1.functions.NODE_UPDATE);
            this.tags = yield this.getTags();
            const currentState = yield this.api.getNodeState(this.object.data[this.object.data.length - 1]);
            const newState = lodash_1.default.cloneDeepWith(currentState);
            newState.versions[newState.versions.length - 1].reactions.push(yield this.memoReaction(reaction));
            const { data, metadata } = yield this.uploadState(newState);
            const txId = yield this.api.postContractTransaction(this.vaultId, { function: this.function, data }, this.tags, metadata);
            return { transactionId: txId };
        });
    }
    /**
     * @param  {string} memoId
     * @param  {reactionEmoji} reaction
     * @returns Promise with corresponding transaction id
     */
    removeReaction(memoId, reaction) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromObjectId(memoId, this.objectType);
            this.setActionRef(constants_1.actionRefs.MEMO_REMOVE_REACTION);
            this.setFunction(constants_1.functions.NODE_UPDATE);
            this.tags = yield this.getTags();
            const body = yield this.deleteReaction(reaction);
            const { data, metadata } = yield this.uploadState(body);
            const txId = yield this.api.postContractTransaction(this.vaultId, { function: this.function, data }, this.tags, metadata);
            return { transactionId: txId };
        });
    }
    memoVersion(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const version = {
                owner: yield this.wallet.getAddress(),
                message: yield this.processWriteString(message),
                createdAt: JSON.stringify(Date.now()),
                reactions: [],
                attachments: []
            };
            return new node_2.MemoVersion(version);
        });
    }
    memoReaction(reactionEmoji) {
        return __awaiter(this, void 0, void 0, function* () {
            const reaction = {
                reaction: yield this.processWriteString(reactionEmoji),
                owner: yield this.wallet.getAddress(),
                createdAt: JSON.stringify(Date.now())
            };
            return new node_2.MemoReaction(reaction);
        });
    }
    deleteReaction(reaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentState = yield this.api.getNodeState(this.object.data[this.object.data.length - 1]);
            const index = yield this.getReactionIndex(currentState.versions[currentState.versions.length - 1].reactions, reaction);
            const newState = lodash_1.default.cloneDeepWith(currentState);
            newState.versions[newState.versions.length - 1].reactions.splice(index, 1);
            return newState;
        });
    }
    getReactionIndex(reactions, reaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.wallet.getAddress();
            const publicSigningKey = yield this.wallet.signingPublicKey();
            for (const [key, value] of Object.entries(reactions)) {
                if ((value.owner === address || value.address === address || value.publicSigningKey === publicSigningKey)
                    && reaction === (yield this.processReadString(value.reaction))) {
                    return key;
                }
            }
            throw new Error("Could not find reaction: " + reaction + " for given user.");
        });
    }
}
exports.MemoService = MemoService;
MemoService.reactionEmoji = constants_1.reactionEmoji;
;
