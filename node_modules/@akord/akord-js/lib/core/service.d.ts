import { Api } from "../api/api";
import { Wallet, Encrypter, EncryptionKeys } from "@akord/crypto";
import { functions } from '../constants';
import { Vault } from "../types/vault";
import { Tags } from "../types/contract";
import { NodeLike } from "../types/node";
import { Membership, MembershipKeys } from "../types/membership";
import { Object, ObjectType } from "../types/object";
declare class Service {
    api: Api;
    wallet: Wallet;
    dataEncrypter: Encrypter;
    membershipKeys: MembershipKeys;
    vaultId: string;
    objectId: string;
    objectType: ObjectType;
    function: functions;
    isPublic: boolean;
    vault: Vault;
    object: Object;
    actionRef: string;
    groupRef: string;
    tags: Tags;
    constructor(wallet: Wallet, api: Api, encryptionKeys?: EncryptionKeys);
    protected setVaultContext(vaultId: string): Promise<void>;
    protected setVaultContextFromObjectId(objectId: string, objectType: ObjectType, vaultId?: string): Promise<void>;
    protected setMembershipKeys(vaultId: string): Promise<void>;
    protected nodeRename(name: string): Promise<{
        transactionId: string;
    }>;
    protected nodeUpdate(body?: any, clientInput?: any, clientMetadata?: any): Promise<{
        transactionId: string;
    }>;
    protected nodeCreate(body?: any, clientInput?: any, clientMetadata?: any): Promise<{
        nodeId: string;
        transactionId: string;
    }>;
    setKeys(keys: any): void;
    setVaultId(vaultId: string): void;
    protected setObjectId(objectId: string): void;
    protected setObjectType(objectType: ObjectType): void;
    protected setFunction(functionName: functions): void;
    protected setActionRef(actionRef: string): void;
    setGroupRef(groupRef: string): void;
    setIsPublic(isPublic: boolean): void;
    setVault(vault: Vault): void;
    protected setObject(object: NodeLike | Membership | Vault): void;
    setRawDataEncryptionPublicKey(publicKey: any): void;
    protected getProfileDetails(): Promise<any>;
    protected processWriteRaw(data: any, encryptedKey?: string): Promise<{
        processedData: any;
        encryptionTags: Tags;
    }>;
    protected getActiveKey(): Promise<{
        address: string;
        publicKey: string;
    }>;
    protected processWriteString(data: string): Promise<string>;
    protected getAvatarUri(profileDetails: any): any;
    protected processAvatar(avatar: any, shouldBundleTransaction?: boolean): Promise<{
        resourceTx: string;
        resourceUrl?: string;
    }>;
    protected processMemberDetails(memberDetails: any, shouldBundleTransaction?: boolean): Promise<any>;
    protected processReadString(data: any, shouldDecrypt?: boolean): Promise<any>;
    processReadRaw(data: any, headers: any, shouldDecrypt?: boolean): Promise<any>;
    protected getEncryptedData(data: any, headers: any): {
        encryptedKey: any;
        encryptedData: {
            iv: Uint8Array;
            ciphertext: any;
        };
        publicKeyIndex: any;
    };
    protected mergeAndUploadBody(body: any): Promise<{
        metadata: {
            dataRefs: {
                modelId: string;
                modelType: ObjectType;
                data: any;
                id: string;
                resourceTx: string;
            }[];
        };
        data: string;
    }>;
    protected signData(data: any): Promise<string>;
    protected uploadState(state: any): Promise<{
        metadata: {
            dataRefs: {
                modelId: string;
                modelType: ObjectType;
                data: any;
                id: string;
                resourceTx: string;
            }[];
        };
        data: string;
    }>;
    protected mergeState(stateUpdates: any): Promise<any>;
    protected getUserEncryptionInfo(email?: string, userAddress?: string): Promise<{
        address: string;
        publicKey: Uint8Array;
    }>;
    protected getTags(): Promise<Tags>;
}
export { Service };
