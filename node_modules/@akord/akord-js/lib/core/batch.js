"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchService = void 0;
const core_1 = require("../core");
const uuid_1 = require("uuid");
const membership_1 = require("./membership");
const stack_1 = require("./stack");
function* chunks(arr, n) {
    for (let i = 0; i < arr.length; i += n) {
        yield arr.slice(i, i + n);
    }
}
class BatchService extends core_1.Service {
    /**
     * @param  {{id:string,type:NoteType}[]} items
     * @returns Promise with corresponding transaction ids
     */
    revoke(items) {
        return __awaiter(this, void 0, void 0, function* () {
            this.setGroupRef(items);
            const transactionIds = [];
            yield Promise.all(items.map((item) => __awaiter(this, void 0, void 0, function* () {
                const service = new core_1.ServiceFactory(this.wallet, this.api, item.type).serviceInstance();
                service.setGroupRef(this.groupRef);
                transactionIds.push(yield service.revoke(item.id));
            })));
            return transactionIds;
        });
    }
    /**
     * @param  {{id:string,type:NoteType}[]} items
     * @returns Promise with corresponding transaction ids
     */
    restore(items) {
        return __awaiter(this, void 0, void 0, function* () {
            this.setGroupRef(items);
            const transactionIds = [];
            yield Promise.all(items.map((item) => __awaiter(this, void 0, void 0, function* () {
                const service = new core_1.ServiceFactory(this.wallet, this.api, item.type).serviceInstance();
                service.setGroupRef(this.groupRef);
                transactionIds.push(yield service.restore(item.id));
            })));
            return transactionIds;
        });
    }
    /**
     * @param  {{id:string,type:NodeType}[]} items
     * @returns Promise with corresponding transaction ids
     */
    delete(items) {
        return __awaiter(this, void 0, void 0, function* () {
            this.setGroupRef(items);
            const transactionIds = [];
            yield Promise.all(items.map((item) => __awaiter(this, void 0, void 0, function* () {
                const service = new core_1.ServiceFactory(this.wallet, this.api, item.type).serviceInstance();
                service.setGroupRef(this.groupRef);
                transactionIds.push(yield service.delete(item.id));
            })));
            return transactionIds;
        });
    }
    /**
     * @param  {{id:string,type:NodeType}[]} items
     * @returns Promise with corresponding transaction ids
     */
    move(items, parentId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.setGroupRef(items);
            const transactionIds = [];
            yield Promise.all(items.map((item) => __awaiter(this, void 0, void 0, function* () {
                const service = new core_1.ServiceFactory(this.wallet, this.api, item.type).serviceInstance();
                service.setGroupRef(this.groupRef);
                transactionIds.push(yield service.move(item.id, parentId));
            })));
            return transactionIds;
        });
    }
    /**
     * @param  {{id:string,role:RoleType}[]} items
     * @returns Promise with corresponding transaction ids
     */
    membershipChangeRole(items) {
        return __awaiter(this, void 0, void 0, function* () {
            this.setGroupRef(items);
            const response = [];
            yield Promise.all(items.map((item) => __awaiter(this, void 0, void 0, function* () {
                const service = new membership_1.MembershipService(this.wallet, this.api);
                service.setGroupRef(this.groupRef);
                response.push(yield service.changeRole(item.id, item.role));
            })));
            return response;
        });
    }
    /**
     * @param  {string} vaultId
     * @param  {{file:FileLike,name:string}[]} items
     * @param  {string} [parentId]
     * @param  {(progress:number)=>void} [progressHook]
     * @param  {AbortController} [cancelHook]
     * @returns Promise with new stack ids & their corresponding transaction ids
     */
    stackCreate(vaultId, items, progressHook, cancelHook, processingCountHook, onStackCreated) {
        return __awaiter(this, void 0, void 0, function* () {
            const size = items.reduce((sum, stack) => {
                return sum + stack.file.size;
            }, 0);
            let progress = 0;
            let processedStacksCount = 0;
            const perFileProgress = new Map();
            this.setGroupRef(items);
            if (processingCountHook) {
                processingCountHook(processedStacksCount);
            }
            const data = [];
            const errors = [];
            const stackProgressHook = (localProgress, data) => {
                const stackBytesUploaded = Math.floor(localProgress / 100 * data.total);
                progress += stackBytesUploaded - (perFileProgress.get(data.id) || 0);
                perFileProgress.set(data.id, stackBytesUploaded);
                progressHook(Math.min(100, Math.round(progress / size * 100)));
            };
            for (const chunk of [...chunks(items, BatchService.BATCH_CHUNK_SIZE)]) {
                yield Promise.all(chunk.map((item) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        const service = new stack_1.StackService(this.wallet, this.api);
                        service.setGroupRef(this.groupRef);
                        const stackResponse = yield service.create(vaultId, item.file, item.name, item.parentId, stackProgressHook, cancelHook);
                        if (cancelHook.signal.aborted) {
                            return { data, errors, cancelled: items.length - processedStacksCount };
                        }
                        data.push(stackResponse);
                        processedStacksCount += 1;
                        processingCountHook(processedStacksCount);
                        if (onStackCreated) {
                            yield onStackCreated(item);
                        }
                    }
                    catch (e) {
                        errors.push({ name: item.name, message: e.toString() });
                    }
                    ;
                })));
                if (cancelHook.signal.aborted) {
                    return { data, errors, cancelled: items.length - processedStacksCount };
                }
            }
            return { data, errors, cancelled: 0 };
        });
    }
    /**
     * @param  {string} vaultId
     * @param  {{email:string,role:RoleType}[]} items
     * @returns Promise with new membership ids & their corresponding transaction ids
     */
    membershipInvite(vaultId, items) {
        return __awaiter(this, void 0, void 0, function* () {
            this.setGroupRef(items);
            const members = yield this.api.getMembers(vaultId);
            const data = [];
            const errors = [];
            yield Promise.all(items.map((item) => __awaiter(this, void 0, void 0, function* () {
                const { email, role } = item;
                const member = members.find(item => item.email === email);
                if (member) {
                    errors.push({ email: email, message: "Membership already exists for this user." });
                }
                else {
                    const userHasAccount = Boolean(yield this.api.getUserFromEmail(email));
                    const service = new membership_1.MembershipService(this.wallet, this.api);
                    service.setGroupRef(this.groupRef);
                    if (userHasAccount) {
                        data.push(yield service.invite(vaultId, email, role));
                    }
                    else {
                        data.push(Object.assign(Object.assign({}, (yield service.inviteNewUser(vaultId, email, role))), { transactionId: null }));
                    }
                }
            })));
            return { data: data, errors: errors };
        });
    }
    setGroupRef(items) {
        this.groupRef = items && items.length > 1 ? (0, uuid_1.v4)() : null;
    }
}
exports.BatchService = BatchService;
BatchService.BATCH_CHUNK_SIZE = 50;
