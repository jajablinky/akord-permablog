"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileService = void 0;
const service_1 = require("./service");
const constants_1 = require("../constants");
const crypto_1 = require("@akord/crypto");
const logger_1 = require("../logger");
const api_client_1 = require("../api/api-client");
const uuid_1 = require("uuid");
const fs_1 = __importDefault(require("fs"));
const contract_1 = require("../types/contract");
class FileService extends service_1.Service {
    constructor() {
        super(...arguments);
        this.asyncUploadTreshold = 209715200;
        this.chunkSize = 209715200;
    }
    /**
     * Returns file as ArrayBuffer. Puts the whole file into memory.
     * For downloading without putting whole file to memory use FileService#download()
     * @param  {string} id file resource url
     * @param  {string} vaultId
     * @param  {DownloadOptions} [options]
     * @returns Promise with file buffer
     */
    get(id, vaultId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (id && id.startsWith('public/')) {
                this.setIsPublic(true);
            }
            else {
                yield this.setVaultContext(vaultId);
            }
            let fileBinary;
            if (options.isChunked) {
                let currentChunk = 0;
                while (currentChunk < options.numberOfChunks) {
                    const url = `${id}_${currentChunk}`;
                    const chunkBinary = yield this.getBinary(url, options.progressHook, options.cancelHook, options.numberOfChunks, currentChunk * this.chunkSize, options.size);
                    fileBinary = this.appendBuffer(fileBinary, chunkBinary);
                    currentChunk++;
                }
            }
            else {
                const file = yield this.api.downloadFile(id, this.isPublic, options.progressHook, options.cancelHook);
                fileBinary = yield this.processReadRaw(file.fileData, file.headers);
            }
            return fileBinary;
        });
    }
    /**
     * Downloads the file keeping memory consumed (RAM) under defiend level: this#chunkSize.
     * In browser, streaming of the binary requires self hosting of mitm.html and sw.js
     * See: https://github.com/jimmywarting/StreamSaver.js#configuration
     * @param  {string} id file resource url
     * @param  {string} vaultId
     * @param  {DownloadOptions} [options]
     * @returns Promise with file buffer
     */
    download(id, vaultId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (id && id.startsWith('public/')) {
                this.setIsPublic(true);
            }
            else {
                yield this.setVaultContext(vaultId);
            }
            const writer = yield this.stream(options.name, options.size);
            if (options.isChunked) {
                let currentChunk = 0;
                try {
                    while (currentChunk < options.numberOfChunks) {
                        const url = `${id}_${currentChunk}`;
                        const fileBinary = yield this.getBinary(url, options.progressHook, options.cancelHook, options.numberOfChunks, currentChunk * this.chunkSize, options.size);
                        if (writer instanceof WritableStreamDefaultWriter) {
                            yield writer.ready;
                        }
                        yield writer.write(new Uint8Array(fileBinary));
                        currentChunk++;
                    }
                }
                catch (err) {
                    throw new Error(err);
                }
                finally {
                    if (writer instanceof WritableStreamDefaultWriter) {
                        yield writer.ready;
                    }
                    yield writer.close();
                }
            }
            else {
                const fileBinary = yield this.getBinary(id, options.progressHook, options.cancelHook);
                yield writer.write(new Uint8Array(fileBinary));
                yield writer.close();
            }
        });
    }
    create(file, shouldBundleTransaction, progressHook, cancelHook) {
        return __awaiter(this, void 0, void 0, function* () {
            const tags = [];
            if (this.isPublic) {
                tags.push(new contract_1.Tag(constants_1.fileTags.FILE_NAME, encodeURIComponent(file.name)));
                if (file.lastModified) {
                    tags.push(new contract_1.Tag(constants_1.fileTags.FILE_MODIFIED_AT, file.lastModified.toString()));
                }
            }
            tags.push(new contract_1.Tag(constants_1.smartweaveTags.CONTENT_TYPE, file.type));
            tags.push(new contract_1.Tag(constants_1.fileTags.FILE_SIZE, file.size));
            tags.push(new contract_1.Tag(constants_1.fileTags.FILE_TYPE, file.type));
            tags.push(new contract_1.Tag(constants_1.protocolTags.TIMESTAMP, JSON.stringify(Date.now())));
            tags.push(new contract_1.Tag(constants_1.dataTags.DATA_TYPE, "File"));
            tags.push(new contract_1.Tag(constants_1.protocolTags.VAULT_ID, this.vaultId));
            if (file.size > this.asyncUploadTreshold) {
                return yield this.uploadChunked(file, tags, progressHook, cancelHook);
            }
            else {
                const { processedData, encryptionTags } = yield this.processWriteRaw(yield file.arrayBuffer());
                const resourceHash = yield (0, crypto_1.digestRaw)(processedData);
                tags.push(new contract_1.Tag(constants_1.fileTags.FILE_HASH, resourceHash));
                return Object.assign({ resourceHash: resourceHash }, yield this.api.uploadFile(processedData, tags.concat(encryptionTags), this.isPublic, shouldBundleTransaction, progressHook, cancelHook));
            }
        });
    }
    stream(path, size) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof window === 'undefined') {
                return fs_1.default.createWriteStream(path);
            }
            else {
                const streamSaver = (yield Promise.resolve().then(() => __importStar(require('streamsaver')))).default;
                if (!streamSaver.WritableStream) {
                    const pony = yield Promise.resolve().then(() => __importStar(require('web-streams-polyfill/ponyfill')));
                    streamSaver.WritableStream = pony.WritableStream;
                }
                if (window.location.protocol === 'https:'
                    || window.location.protocol === 'chrome-extension:'
                    || window.location.hostname === 'localhost') {
                    streamSaver.mitm = '/streamsaver/mitm.html';
                }
                const fileStream = streamSaver.createWriteStream(path, { size: size, writableStrategy: new ByteLengthQueuingStrategy({ highWaterMark: 3 * this.chunkSize }) });
                return fileStream.getWriter();
            }
        });
    }
    uploadChunked(file, tags, progressHook, cancelHook) {
        return __awaiter(this, void 0, void 0, function* () {
            let resourceUrl = (0, uuid_1.v4)();
            let encryptionTags;
            let encryptedKey;
            let iv = [];
            let uploadedChunks = 0;
            let offset = 0;
            while (offset < file.size) {
                const chunk = file.slice(offset, this.chunkSize + offset);
                const { encryptedData, chunkNumber } = yield this.encryptChunk(chunk, offset, encryptedKey);
                encryptionTags = encryptedData.encryptionTags;
                if (!this.isPublic) {
                    iv.push(encryptionTags.find((tag) => tag.name === constants_1.encryptionTags.IV).value);
                    if (!encryptedKey) {
                        encryptedKey = encryptionTags.find((tag) => tag.name === constants_1.encryptionTags.ENCRYPTED_KEY).value;
                    }
                }
                yield this.uploadChunk(encryptedData, chunkNumber, tags, resourceUrl, file.size, progressHook, cancelHook);
                offset += this.chunkSize;
                uploadedChunks += 1;
                logger_1.Logger.log("Encrypted & uploaded chunk: " + chunkNumber);
            }
            if (!this.isPublic) {
                const ivIndex = encryptionTags.findIndex((tag) => tag.name === constants_1.encryptionTags.IV);
                encryptionTags[ivIndex] = new contract_1.Tag(constants_1.encryptionTags.IV, iv.join(','));
            }
            yield new api_client_1.ApiClient()
                .env(this.api.config)
                .auth(this.api.jwtToken)
                .resourceId(resourceUrl)
                .tags(tags.concat(encryptionTags))
                .public(this.isPublic)
                .numberOfChunks(uploadedChunks)
                .asyncTransaction();
            return {
                resourceUrl: resourceUrl,
                resourceHash: resourceUrl,
                numberOfChunks: uploadedChunks,
                chunkSize: this.chunkSize
            };
        });
    }
    uploadChunk(chunk, chunkNumber, tags, resourceUrl, resourceSize, progressHook, cancelHook) {
        return __awaiter(this, void 0, void 0, function* () {
            const resource = yield new api_client_1.ApiClient()
                .env(this.api.config)
                .auth(this.api.jwtToken)
                .resourceId(`${resourceUrl}_${chunkNumber}`)
                .data(chunk.processedData)
                .tags(tags.concat(chunk.encryptionTags))
                .public(this.isPublic)
                .bundle(false)
                .progressHook(progressHook, chunkNumber * this.chunkSize, resourceSize)
                .cancelHook(cancelHook)
                .uploadFile();
            logger_1.Logger.log("Uploaded file with id: " + resource.resourceUrl);
        });
    }
    encryptChunk(chunk, offset, encryptedKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const chunkNumber = offset / this.chunkSize;
            const arrayBuffer = yield chunk.arrayBuffer();
            const encryptedData = yield this.processWriteRaw(new Uint8Array(arrayBuffer), encryptedKey);
            return { encryptedData, chunkNumber };
        });
    }
    appendBuffer(buffer1, buffer2) {
        if (!buffer1 && !buffer2)
            return;
        if (!buffer1)
            return buffer2;
        if (!buffer2)
            return buffer1;
        var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
        tmp.set(new Uint8Array(buffer1), 0);
        tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
        return tmp.buffer;
    }
    getBinary(id, progressHook, cancelHook, numberOfChunks, loadedSize, resourceSize) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const file = yield this.api.downloadFile(id, this.isPublic, progressHook, cancelHook, numberOfChunks, loadedSize, resourceSize);
                return yield this.processReadRaw(file.fileData, file.headers);
            }
            catch (e) {
                logger_1.Logger.log(e);
                throw new Error("Failed to download. Please check your network connection." +
                    " Please upload the file again if problem persists and/or contact Akord support.");
            }
        });
    }
}
exports.FileService = FileService;
;
