"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = void 0;
const crypto_1 = require("@akord/crypto");
const uuid_1 = require("uuid");
const constants_1 = require("../constants");
const lodash_1 = __importDefault(require("lodash"));
const contract_1 = require("../types/contract");
class Service {
    constructor(wallet, api, encryptionKeys) {
        this.wallet = wallet;
        this.api = api;
        // for the data encryption
        this.dataEncrypter = new crypto_1.EncrypterFactory(wallet, encryptionKeys).encrypterInstance();
    }
    setVaultContext(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const vault = yield this.api.getObject(vaultId, constants_1.objectType.VAULT, vaultId);
            this.setVault(vault);
            this.setVaultId(vaultId);
            this.setIsPublic(vault.public);
            yield this.setMembershipKeys(vaultId);
        });
    }
    setVaultContextFromObjectId(objectId, objectType, vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const object = yield this.api.getObject(objectId, objectType, this.vaultId);
            yield this.setVaultContext(vaultId || object.vaultId);
            this.setObject(object);
            this.setObjectId(objectId);
            this.setObjectType(objectType);
        });
    }
    setMembershipKeys(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isPublic) {
                const encryptionKeys = yield this.api.getMembershipKeys(vaultId);
                const keys = encryptionKeys.keys.map(((keyPair) => {
                    return {
                        encPrivateKey: keyPair.encPrivateKey,
                        publicKey: keyPair.publicKey ? keyPair.publicKey : keyPair.encPublicKey
                    };
                }));
                this.setKeys(keys);
                if (encryptionKeys.publicKey) {
                    this.setRawDataEncryptionPublicKey((0, crypto_1.base64ToArray)(encryptionKeys.publicKey));
                }
                else {
                    const publicKey = yield this.dataEncrypter.wallet.decrypt(encryptionKeys.keys[encryptionKeys.keys.length - 1].encPublicKey);
                    this.setRawDataEncryptionPublicKey(publicKey);
                }
            }
        });
    }
    nodeRename(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                name: yield this.processWriteString(name)
            };
            this.setFunction(this.objectType === "Vault" ? constants_1.functions.VAULT_UPDATE : constants_1.functions.NODE_UPDATE);
            return this.nodeUpdate(body);
        });
    }
    nodeUpdate(body, clientInput, clientMetadata) {
        return __awaiter(this, void 0, void 0, function* () {
            const input = Object.assign({ function: this.function }, clientInput);
            this.tags = yield this.getTags();
            if (body) {
                const { data, metadata } = yield this.mergeAndUploadBody(body);
                input.data = data;
                clientMetadata = Object.assign(Object.assign({}, clientMetadata), metadata);
            }
            const txId = yield this.api.postContractTransaction(this.vaultId, input, this.tags, clientMetadata);
            return { transactionId: txId };
        });
    }
    nodeCreate(body, clientInput, clientMetadata) {
        return __awaiter(this, void 0, void 0, function* () {
            const nodeId = (0, uuid_1.v4)();
            this.setObjectId(nodeId);
            this.setFunction(constants_1.functions.NODE_CREATE);
            this.tags = yield this.getTags();
            const { metadata, data } = yield this.uploadState(body);
            const input = Object.assign({ function: this.function, data }, clientInput);
            const txId = yield this.api.postContractTransaction(this.vaultId, input, this.tags, Object.assign(Object.assign({}, metadata), clientMetadata));
            this.setActionRef(null);
            return { nodeId, transactionId: txId };
        });
    }
    setKeys(keys) {
        this.membershipKeys = keys;
        this.dataEncrypter.setKeys(keys);
    }
    setVaultId(vaultId) {
        this.vaultId = vaultId;
    }
    setObjectId(objectId) {
        this.objectId = objectId;
    }
    setObjectType(objectType) {
        this.objectType = objectType;
    }
    setFunction(functionName) {
        this.function = functionName;
    }
    setActionRef(actionRef) {
        this.actionRef = actionRef;
    }
    setGroupRef(groupRef) {
        this.groupRef = groupRef;
    }
    setIsPublic(isPublic) {
        this.isPublic = isPublic;
    }
    setVault(vault) {
        this.vault = vault;
    }
    setObject(object) {
        this.object = object;
    }
    setRawDataEncryptionPublicKey(publicKey) {
        this.dataEncrypter.setRawPublicKey(publicKey);
    }
    getProfileDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            const profile = yield this.api.getProfile();
            if (profile) {
                const profileKeys = new crypto_1.EncryptionKeys(profile.state.encryptionType, profile.state.keys, profile.state.encAccessKey, null);
                const profileEncrypter = new crypto_1.EncrypterFactory(this.wallet, profileKeys).encrypterInstance();
                profileEncrypter.decryptedKeys = [
                    {
                        publicKey: yield this.wallet.publicKey(),
                        privateKey: this.wallet.privateKeyRaw()
                    }
                ];
                let profileDetails = profile.state.profileDetails;
                delete profileDetails.__typename;
                let avatar = null;
                const resourceUri = this.getAvatarUri(profileDetails);
                if (resourceUri) {
                    const { fileData, headers } = yield this.api.downloadFile(resourceUri);
                    const encryptedData = this.getEncryptedData(fileData, headers);
                    if (encryptedData) {
                        avatar = yield profileEncrypter.decryptRaw(encryptedData, false);
                    }
                    else {
                        const dataString = (0, crypto_1.arrayToString)(new Uint8Array(fileData.data));
                        avatar = yield profileEncrypter.decryptRaw(dataString, true);
                    }
                }
                const decryptedProfile = yield profileEncrypter.decryptObject(profileDetails, ['fullName', 'name', 'phone']);
                decryptedProfile.name = decryptedProfile.name || decryptedProfile.fullName;
                delete decryptedProfile.fullName;
                return Object.assign(Object.assign({}, decryptedProfile), { avatar });
            }
            return {};
        });
    }
    processWriteRaw(data, encryptedKey) {
        return __awaiter(this, void 0, void 0, function* () {
            let processedData;
            const tags = [];
            if (this.isPublic) {
                processedData = data;
            }
            else {
                const encryptedFile = yield this.dataEncrypter.encryptRaw(data, false, encryptedKey);
                processedData = encryptedFile.encryptedData.ciphertext;
                const { address, publicKey } = yield this.getActiveKey();
                tags.push(new contract_1.Tag(constants_1.encryptionTags.IV, encryptedFile.encryptedData.iv));
                tags.push(new contract_1.Tag(constants_1.encryptionTags.ENCRYPTED_KEY, encryptedFile.encryptedKey));
                tags.push(new contract_1.Tag(constants_1.encryptionTags.PUBLIC_ADDRESS, address));
            }
            return { processedData, encryptionTags: tags };
        });
    }
    getActiveKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                address: yield (0, crypto_1.deriveAddress)(this.dataEncrypter.publicKey, "akord"),
                publicKey: (0, crypto_1.arrayToBase64)(this.dataEncrypter.publicKey)
            };
        });
    }
    processWriteString(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isPublic)
                return data;
            const encryptedPayload = yield this.dataEncrypter.encryptRaw((0, crypto_1.stringToArray)(data));
            const decodedPayload = (0, crypto_1.base64ToJson)(encryptedPayload);
            decodedPayload.publicAddress = (yield this.getActiveKey()).address;
            delete decodedPayload.publicKey;
            return (0, crypto_1.jsonToBase64)(decodedPayload);
        });
    }
    getAvatarUri(profileDetails) {
        var _a;
        if (profileDetails.avatarUri && profileDetails.avatarUri.length) {
            return (_a = [...profileDetails.avatarUri].reverse().find(resourceUri => resourceUri.startsWith("s3:"))) === null || _a === void 0 ? void 0 : _a.replace("s3:", "");
        }
        else if (profileDetails.avatarUrl) {
            return profileDetails.avatarUrl;
        }
        return null;
    }
    processAvatar(avatar, shouldBundleTransaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const { processedData, encryptionTags } = yield this.processWriteRaw(avatar);
            return this.api.uploadFile(processedData, encryptionTags, false, shouldBundleTransaction);
        });
    }
    processMemberDetails(memberDetails, shouldBundleTransaction) {
        return __awaiter(this, void 0, void 0, function* () {
            let processedMemberDetails = {};
            if (memberDetails.name) {
                processedMemberDetails.name = yield this.processWriteString(memberDetails.name);
            }
            if (memberDetails.avatar) {
                const { resourceUrl, resourceTx } = yield this.processAvatar(memberDetails.avatar, shouldBundleTransaction);
                processedMemberDetails.avatarUri = [`arweave:${resourceTx}`, `s3:${resourceUrl}`];
            }
            return processedMemberDetails;
        });
    }
    processReadString(data, shouldDecrypt = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isPublic || !shouldDecrypt)
                return data;
            const decryptedDataRaw = yield this.processReadRaw(data, {});
            return (0, crypto_1.arrayToString)(decryptedDataRaw);
        });
    }
    processReadRaw(data, headers, shouldDecrypt = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isPublic || !shouldDecrypt) {
                return Buffer.from(data.data);
            }
            const encryptedData = this.getEncryptedData(data, headers);
            if (encryptedData) {
                return this.dataEncrypter.decryptRaw(encryptedData, false);
            }
            else {
                return this.dataEncrypter.decryptRaw(data);
            }
        });
    }
    getEncryptedData(data, headers) {
        const encryptedKey = headers['x-amz-meta-encryptedkey'];
        const iv = headers['x-amz-meta-iv'];
        const publicKeyIndex = headers['x-amz-meta-public-key-index'];
        if (encryptedKey && iv) {
            return {
                encryptedKey,
                encryptedData: {
                    iv: (0, crypto_1.base64ToArray)(iv),
                    ciphertext: data
                },
                publicKeyIndex
            };
        }
        return null;
    }
    mergeAndUploadBody(body) {
        return __awaiter(this, void 0, void 0, function* () {
            const mergedBody = yield this.mergeState(body);
            return this.uploadState(mergedBody);
        });
    }
    signData(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wallet instanceof crypto_1.AkordWallet) {
                const encodedBody = (0, crypto_1.jsonToBase64)(data);
                const privateKeyRaw = yield this.wallet.signingPrivateKeyRaw();
                const signature = yield (0, crypto_1.signString)(encodedBody, privateKeyRaw);
                return signature;
            }
            else {
                return "--TODO--";
            }
        });
    }
    uploadState(state) {
        return __awaiter(this, void 0, void 0, function* () {
            const signature = yield this.signData(state);
            const tags = [
                new contract_1.Tag(constants_1.dataTags.DATA_TYPE, "State"),
                new contract_1.Tag(constants_1.protocolTags.SIGNATURE, signature),
                new contract_1.Tag(constants_1.protocolTags.SIGNER_ADDRESS, yield this.wallet.getAddress()),
                new contract_1.Tag(constants_1.protocolTags.VAULT_ID, this.vaultId),
                new contract_1.Tag(constants_1.protocolTags.NODE_TYPE, this.objectType),
            ];
            if (this.objectType === constants_1.objectType.MEMBERSHIP) {
                tags.push(new contract_1.Tag(constants_1.protocolTags.MEMBERSHIP_ID, this.objectId));
            }
            else if (this.objectType !== constants_1.objectType.VAULT) {
                tags.push(new contract_1.Tag(constants_1.protocolTags.NODE_ID, this.objectId));
            }
            const ids = yield this.api.uploadData([{ data: state, tags }], true);
            const metadata = {
                dataRefs: [
                    Object.assign(Object.assign({}, ids[0]), { modelId: this.objectId, modelType: this.objectType, data: state })
                ]
            };
            const data = ids[0].id;
            return { metadata, data };
        });
    }
    mergeState(stateUpdates) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentState = this.object.data ? yield this.api.getNodeState(this.object.data[this.object.data.length - 1]) : {};
            let newState = lodash_1.default.cloneDeepWith(currentState);
            lodash_1.default.mergeWith(newState, stateUpdates, function concatArrays(objValue, srcValue) {
                if (lodash_1.default.isArray(objValue)) {
                    return objValue.concat(srcValue);
                }
            });
            return newState;
        });
    }
    getUserEncryptionInfo(email, userAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const { address, publicKey } = yield this.api.getUserFromEmail(email || userAddress);
            return { address, publicKey: (0, crypto_1.base64ToArray)(publicKey) };
        });
    }
    getTags() {
        return __awaiter(this, void 0, void 0, function* () {
            const tags = [
                new contract_1.Tag(constants_1.protocolTags.FUNCTION_NAME, this.function),
                new contract_1.Tag(constants_1.protocolTags.SIGNER_ADDRESS, yield this.wallet.getAddress()),
                new contract_1.Tag(constants_1.protocolTags.VAULT_ID, this.vaultId),
                new contract_1.Tag(constants_1.protocolTags.TIMESTAMP, JSON.stringify(Date.now())),
                new contract_1.Tag(constants_1.protocolTags.NODE_TYPE, this.objectType),
            ];
            if (this.groupRef) {
                tags.push(new contract_1.Tag("Group-Ref", this.groupRef));
            }
            if (this.actionRef) {
                tags.push(new contract_1.Tag("Action-Ref", this.actionRef));
            }
            if (this.objectType === constants_1.objectType.MEMBERSHIP) {
                tags.push(new contract_1.Tag(constants_1.protocolTags.MEMBERSHIP_ID, this.objectId));
            }
            else if (this.objectType !== constants_1.objectType.VAULT) {
                tags.push(new contract_1.Tag(constants_1.protocolTags.NODE_ID, this.objectId));
            }
            return tags;
        });
    }
}
exports.Service = Service;
