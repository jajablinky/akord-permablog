"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArweaveWallet = exports.KeyType = void 0;
const arweave_1 = __importDefault(require("arweave"));
const functions_1 = require("../functions");
const encoding_1 = require("../encoding");
const nodeCrypto = __importStar(require("crypto"));
const crypto = typeof window === 'undefined' ? nodeCrypto.webcrypto : window.crypto;
var KeyType;
(function (KeyType) {
    KeyType["JWK"] = "JWK";
    KeyType["ARCONNECT"] = "ARCONNECT";
})(KeyType = exports.KeyType || (exports.KeyType = {}));
class ArweaveWallet {
    constructor(jwk) {
        this.arweave = arweave_1.default.init({
            host: 'arweave.net',
            port: 443,
            protocol: 'https'
        });
        if (jwk) {
            this.keyType = KeyType.JWK;
            this.wallet = jwk;
        }
        else {
            this.keyType = KeyType.ARCONNECT;
            this.wallet = window.arweaveWallet;
        }
    }
    signingPrivateKeyRaw() {
        throw new Error('Method not implemented.');
    }
    signingPrivateKey() {
        throw new Error('Method not implemented.');
    }
    encrypt(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const string = (0, encoding_1.arrayToBase64)(input);
            const array = new Uint8Array(256);
            const keyBuf = crypto.getRandomValues(array);
            const encryptedData = yield arweave_1.default.crypto.encrypt((0, encoding_1.stringToArray)(string), keyBuf);
            const publicKey = yield this.publicKeyRaw();
            const encryptedKey = yield crypto.subtle.encrypt({ name: 'RSA-OAEP' }, publicKey, keyBuf);
            const buffer = arweave_1.default.utils.concatBuffers([encryptedKey, encryptedData]);
            return (0, encoding_1.arrayToBase64)(buffer);
        });
    }
    encryptToPublicKey(input, publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const string = (0, encoding_1.arrayToBase64)(input);
            const array = new Uint8Array(256);
            const keyBuf = crypto.getRandomValues(array);
            const encryptedData = yield arweave_1.default.crypto.encrypt((0, encoding_1.stringToArray)(string), keyBuf);
            const encryptedKey = yield crypto.subtle.encrypt({ name: 'RSA-OAEP' }, publicKey, keyBuf);
            const buffer = arweave_1.default.utils.concatBuffers([encryptedKey, encryptedData]);
            return (0, encoding_1.arrayToBase64)(buffer);
        });
    }
    decrypt(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield (0, functions_1.importRSACryptoKey)(this.wallet);
            const data = (0, encoding_1.base64ToArray)(input);
            const encryptedKey = new Uint8Array(new Uint8Array(Object.values(data)).slice(0, 512));
            const encryptedData = new Uint8Array(new Uint8Array(Object.values(data)).slice(512));
            const symmetricKey = yield crypto.subtle.decrypt({ name: "RSA-OAEP" }, key, encryptedKey);
            const res = yield this.arweave.crypto.decrypt(encryptedData, new Uint8Array(symmetricKey));
            return (0, encoding_1.base64ToArray)(this.arweave.utils.bufferToString(res).split(null)[0]);
        });
    }
    publicKeyRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const publicKey = yield this.publicKey();
            return (0, functions_1.importRSAPublicKey)(publicKey);
        });
    }
    publicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.keyType === KeyType.JWK) {
                return this.wallet.n;
            }
            else {
                return this.wallet.getActivePublicKey();
            }
        });
    }
    privateKeyRaw() {
        throw new Error('Method not implemented.');
    }
    signingPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.publicKey();
        });
    }
    signingPublicKeyRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.publicKeyRaw();
        });
    }
    sign(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const signatureOptions = {
                name: "RSA-PSS",
                saltLength: 32,
            };
            let rawSignature;
            if (this.keyType === KeyType.JWK) {
                rawSignature = yield this.arweave.crypto.sign(this.wallet, data);
            }
            else {
                rawSignature = yield this.wallet.signature(data, signatureOptions);
            }
            const signature = this.arweave.utils.bufferTob64(rawSignature);
            return signature;
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.arweave.wallets.jwkToAddress(this.keyType === KeyType.JWK
                ? this.wallet
                : "use-wallet");
            return address;
        });
    }
    getPublicKeyFromAddress(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const publicKey = yield this._getPublicKeyFromAddress(address);
            return (0, functions_1.importRSAPublicKey)(publicKey);
        });
    }
    _getPublicKeyFromAddress(address) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const transactionId = yield this.arweave.wallets.getLastTransactionID(address);
                if (transactionId) {
                    const transaction = yield this.arweave.transactions.get(transactionId);
                    return transaction.owner;
                }
                else {
                    console.log("Could not find corresponding public key for the given address. Make sure that the member address is registered on the weave, ie. at least one transaction was made with that address.");
                }
            }
            catch (error) {
                console.log("Could not find corresponding public key for the given address. Make sure that the member address is registered on the weave, ie. at least one transaction was made with that address.");
                console.error("Could not find corresponding public key for the given address: " + error);
            }
        });
    }
    ;
}
exports.default = ArweaveWallet;
exports.ArweaveWallet = ArweaveWallet;
//# sourceMappingURL=arweave-wallet.js.map